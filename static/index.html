<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ìŒì„± ì¸ì‹ ë°ëª¨</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; margin-top: 50px; max-width: 800px; margin: 30px auto; }
        button, input[type="file"] { font-size: 18px; padding: 10px 20px; margin: 10px; }
        #result { margin-top: 30px; font-size: 20px; color: #333; }
        .status { font-size: 14px; color: #666; margin-top: 10px; }
        .error { color: red; }
        .recording { color: red; animation: blink 1s infinite; }
        .section { margin: 20px 0; padding: 15px; border: 1px solid #eee; border-radius: 5px; }
        .section-title { font-weight: bold; margin-bottom: 10px; }
        #audioPreview { margin-top: 15px; display: none; width: 100%; }
        #deviceInfo { margin-top: 15px; font-size: 14px; text-align: left; }
        select { padding: 8px; font-size: 16px; margin: 5px; min-width: 250px; }
        @keyframes blink { 50% { opacity: 0.5; } }
    </style>
</head>
<body>

    <h1>ğŸ™ ìŒì„± ë…¹ìŒ & íŒŒì¼ ì—…ë¡œë“œ â†’ í…ìŠ¤íŠ¸ ë³€í™˜</h1>

    <!-- ë§ˆì´í¬ ì¥ì¹˜ ì„ íƒ -->
    <div class="section">
        <div class="section-title">ğŸ¤ ë§ˆì´í¬ ì¥ì¹˜ ì„ íƒ</div>
        <select id="audioDevices">
            <option value="">ë§ˆì´í¬ ì¥ì¹˜ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</option>
        </select>
        <button id="refreshDevices">ì¥ì¹˜ ëª©ë¡ ìƒˆë¡œê³ ì¹¨</button>
        <div id="deviceInfo"></div>
    </div>

    <!-- ë…¹ìŒ -->
    <div class="section">
        <div class="section-title">ğŸ”´ ë…¹ìŒ ì»¨íŠ¸ë¡¤</div>
        <button id="recordBtn">ë…¹ìŒ ì‹œì‘</button>
        <span id="recordingStatus" class="status"></span>
        <div>
            <audio id="audioPreview" controls></audio>
        </div>
    </div>

    <!-- íŒŒì¼ ì—…ë¡œë“œ -->
    <div class="section">
        <div class="section-title">ğŸ“ íŒŒì¼ ì—…ë¡œë“œ</div>
        <input type="file" id="fileInput" accept="audio/*">
        <button id="uploadBtn">íŒŒì¼ ì—…ë¡œë“œ</button>
    </div>

    <div id="result" class="section">
        <div class="section-title">ğŸ“ ë³€í™˜ ê²°ê³¼</div>
        <div id="textOutput">-</div>
    </div>
    <div id="errorOutput" class="error"></div>

    <script>
        const recordBtn = document.getElementById('recordBtn');
        const fileInput = document.getElementById('fileInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const textOutput = document.getElementById('textOutput');
        const errorOutput = document.getElementById('errorOutput');
        const recordingStatus = document.getElementById('recordingStatus');
        const audioPreview = document.getElementById('audioPreview');
        const audioDevices = document.getElementById('audioDevices');
        const refreshDevices = document.getElementById('refreshDevices');
        const deviceInfo = document.getElementById('deviceInfo');

        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let audioStream;
        let currentDeviceId = '';

        // ë§ˆì´í¬ ì¥ì¹˜ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
        async function getAudioDevices() {
            try {
                showStatus(deviceInfo, "ë§ˆì´í¬ ì¥ì¹˜ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...");

                // ì„ì‹œ ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ ìš”ì²­ (ì¥ì¹˜ ì ‘ê·¼ ê¶Œí•œì„ ìœ„í•´)
                const tempStream = await navigator.mediaDevices.getUserMedia({ audio: true });

                // ëª¨ë“  ì¥ì¹˜ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                const devices = await navigator.mediaDevices.enumerateDevices();

                // ì„ì‹œ ìŠ¤íŠ¸ë¦¼ ì¤‘ì§€
                tempStream.getTracks().forEach(track => track.stop());

                // ê¸°ì¡´ ì˜µì…˜ ì œê±°
                audioDevices.innerHTML = '';

                // ì˜¤ë””ì˜¤ ì…ë ¥ ì¥ì¹˜ë§Œ í•„í„°ë§
                const audioInputs = devices.filter(device => device.kind === 'audioinput');

                if (audioInputs.length === 0) {
                    audioDevices.innerHTML = '<option value="">ì‚¬ìš© ê°€ëŠ¥í•œ ë§ˆì´í¬ ì¥ì¹˜ê°€ ì—†ìŠµë‹ˆë‹¤</option>';
                    showStatus(deviceInfo, "ì‚¬ìš© ê°€ëŠ¥í•œ ë§ˆì´í¬ ì¥ì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤", true);
                    return;
                }

                // ì¥ì¹˜ ëª©ë¡ ì¶”ê°€
                audioInputs.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `ë§ˆì´í¬ ${audioDevices.options.length + 1}`;
                    audioDevices.appendChild(option);
                });

                // ì²« ë²ˆì§¸ ì¥ì¹˜ ì„ íƒ
                if (audioInputs.length > 0) {
                    currentDeviceId = audioInputs[0].deviceId;
                    showStatus(deviceInfo, `í˜„ì¬ ì„ íƒëœ ë§ˆì´í¬: ${audioInputs[0].label || 'ê¸°ë³¸ ë§ˆì´í¬'}`);
                }

                showStatus(deviceInfo, `${audioInputs.length}ê°œì˜ ë§ˆì´í¬ ì¥ì¹˜ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤`);
            } catch (error) {
                console.error("ë§ˆì´í¬ ì¥ì¹˜ ëª©ë¡ ê°€ì ¸ì˜¤ê¸° ì˜¤ë¥˜:", error);
                showStatus(deviceInfo, `ë§ˆì´í¬ ì¥ì¹˜ ëª©ë¡ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${error.message}`, true);
                audioDevices.innerHTML = '<option value="">ë§ˆì´í¬ ì ‘ê·¼ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤</option>';
            }
        }

        // ì¥ì¹˜ ë³€ê²½ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        audioDevices.addEventListener('change', function() {
            currentDeviceId = this.value;
            const selectedOption = this.options[this.selectedIndex];
            showStatus(deviceInfo, `ì„ íƒëœ ë§ˆì´í¬: ${selectedOption.text}`);
        });

        // ì¥ì¹˜ ëª©ë¡ ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼
        refreshDevices.addEventListener('click', getAudioDevices);

        // ìƒíƒœ ë° ì˜¤ë¥˜ í‘œì‹œ í•¨ìˆ˜
        function showStatus(element, message, isError = false) {
            element.textContent = message;
            if (isError) {
                element.classList.add('error');
            } else {
                element.classList.remove('error');
            }
        }

        // ê³µí†µ í•¨ìˆ˜: STT ìš”ì²­
        async function sendAudioToServer(audioBlob) {
            const formData = new FormData();

            // Blob ì •ë³´ ë¡œê¹…
            console.log("ì „ì†¡í•  Blob:", audioBlob.type, audioBlob.size, "bytes");

            formData.append('file', audioBlob, 'recording.webm');
            showStatus(textOutput, "ì¸ì‹ ì¤‘...");
            errorOutput.textContent = "";

            try {
                const response = await fetch('/stt', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (response.ok) {
                    showStatus(textOutput, result.text || "ì¸ì‹ëœ í…ìŠ¤íŠ¸ ì—†ìŒ");
                } else {
                    showStatus(textOutput, "ì¸ì‹ ì‹¤íŒ¨");
                    showStatus(errorOutput, `ì˜¤ë¥˜: ${result.error || "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜"}`, true);
                }
            } catch (error) {
                console.error("API ìš”ì²­ ì˜¤ë¥˜:", error);
                showStatus(textOutput, "ì„œë²„ ì—°ê²° ì‹¤íŒ¨");
                showStatus(errorOutput, `ì—°ê²° ì˜¤ë¥˜: ${error.message}`, true);
            }
        }

        // ë…¹ìŒ ë²„íŠ¼ ë™ì‘
        recordBtn.addEventListener('click', async () => {
            if (!isRecording) {
                try {
                    // ì„ íƒëœ ë§ˆì´í¬ë¡œ ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ ìš”ì²­
                    const constraints = {
                        audio: currentDeviceId ? { deviceId: { exact: currentDeviceId } } : true
                    };

                    audioStream = await navigator.mediaDevices.getUserMedia(constraints);

                    // ì‚¬ìš©ì¤‘ì¸ ì¥ì¹˜ ì •ë³´ í‘œì‹œ
                    const track = audioStream.getAudioTracks()[0];
                    if (track) {
                        showStatus(deviceInfo, `ì‚¬ìš© ì¤‘ì¸ ë§ˆì´í¬: ${track.label}`);
                    }

                    // ë¯¸ë””ì–´ ë ˆì½”ë” ì„¤ì •
                    const options = { mimeType: 'audio/webm' };
                    try {
                        mediaRecorder = new MediaRecorder(audioStream, options);
                    } catch (e) {
                        console.warn("audio/webmì´ ì§€ì›ë˜ì§€ ì•Šì•„ ê¸°ë³¸ í˜•ì‹ìœ¼ë¡œ ë…¹ìŒí•©ë‹ˆë‹¤:", e);
                        mediaRecorder = new MediaRecorder(audioStream);
                    }

                    audioChunks = [];

                    // ë°ì´í„° ìˆ˜ì§‘
                    mediaRecorder.ondataavailable = event => {
                        console.log("ë°ì´í„° ì²­í¬ ìˆ˜ì‹ :", event.data.type, event.data.size, "bytes");
                        if (event.data && event.data.size > 0) {
                            audioChunks.push(event.data);
                        }
                    };

                    // ë…¹ìŒ ì¢…ë£Œ ì²˜ë¦¬
                    mediaRecorder.onstop = () => {
                        // Blob ìƒì„±
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        console.log("ë…¹ìŒ ì™„ë£Œ:", audioBlob.type, audioBlob.size, "bytes");

                        // ì˜¤ë””ì˜¤ ë¯¸ë¦¬ë“£ê¸° ì„¤ì •
                        const audioURL = URL.createObjectURL(audioBlob);
                        audioPreview.src = audioURL;
                        audioPreview.style.display = "block";

                        if (audioBlob.size > 0) {
                            sendAudioToServer(audioBlob);
                        } else {
                            showStatus(errorOutput, "ë…¹ìŒëœ ì˜¤ë””ì˜¤ê°€ ì—†ìŠµë‹ˆë‹¤.", true);
                        }
                    };

                    // ë…¹ìŒ ì‹œì‘
                    mediaRecorder.start();
                    recordBtn.textContent = "ë…¹ìŒ ì¤‘ì§€";
                    recordingStatus.textContent = "ë…¹ìŒ ì¤‘...";
                    recordingStatus.classList.add('recording');
                    isRecording = true;

                } catch (error) {
                    console.error("ë…¹ìŒ ì‹œì‘ ì˜¤ë¥˜:", error);
                    showStatus(errorOutput, `ë§ˆì´í¬ ì ‘ê·¼ ì˜¤ë¥˜: ${error.message}`, true);
                }
            } else {
                // ë…¹ìŒ ì¤‘ì§€
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                    // ìŠ¤íŠ¸ë¦¼ íŠ¸ë™ ì¤‘ì§€
                    if (audioStream) {
                        audioStream.getTracks().forEach(track => track.stop());
                    }
                }
                recordBtn.textContent = "ë…¹ìŒ ì‹œì‘";
                recordingStatus.textContent = "ë…¹ìŒ ì™„ë£Œ";
                recordingStatus.classList.remove('recording');
                isRecording = false;
            }
        });

        // ì—…ë¡œë“œ ë²„íŠ¼ ë™ì‘
        uploadBtn.addEventListener('click', () => {
            const file = fileInput.files[0];
            if (!file) {
                showStatus(errorOutput, "ë¨¼ì € ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”.", true);
                return;
            }

            console.log("ì—…ë¡œë“œ íŒŒì¼:", file.name, file.type, file.size, "bytes");
            audioPreview.style.display = "none";
            sendAudioToServer(file);
        });

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ë§ˆì´í¬ ì¥ì¹˜ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
        window.addEventListener('DOMContentLoaded', getAudioDevices);
    </script>

</body>
</html>